Some Git Commands & Examples:

git init : initializes an empty Git (local) repo in the directory it is called from ( and creates hidden .git folder)

git status : shows status of repo (run this often especially before committing changes!!)

git add <filename> : adds file to the staging area

git add -A .  : where the dot stands for the current directory, so everything in and beneath it is added. The -A ensures even file deletions are included.

git add '*.txt' : using wildcards to add files in the current folder and all sub-folders under it. 
(NOTE: Wildcards: We need quotes so that Git will receive the wildcard before our shell can interfere with it. Without quotes our shell will only execute the wildcard search within the current directory. Git will receive the list of files the shell found instead of the wildcard and it will not be able to add the files inside of any sub-directory if they exist.)

git reset <filename>  : to remove a file or files from the staging area.

git commit -m “some description here” : commit command with a message describing what we've changed. This stores our stages changes to the repo.

git log : see all commits (changes) made to the repo in the order and when.

git log --summary : to see more information for each commit. You can see where new files were added for the first time or where files were deleted. It's a good overview of what's going on in the project. 

git remote:  add a remote repository. This command creates a remote repo and needs a remote repo name and a repository URL (where an empty repo has been initialized - this means DO NOT select a readme or .gitignore or license while creating the GitHub empty repo. If you do, the push will fail. Do thatose steps after pushing the local repo to the remote repo). This is typically done when you want to push your local repo to a remote server such as GitHub for ex. Git doesn't care what you name your remotes, but it's typical to name your main one origin.

Example: git remote add origin https://github.com/try-git/try_git.git

git push : tells Git where to put our commits when we're ready

Example: git push -u origin master (The name of our remote is origin in above example and the default local branch name is master. The -u tells Git to remember the parameters, so that next time we can simply run git push and Git will know what to do)

git pull : check for changes on our GitHub remote repository and pull down any new changes to say a local repo.

Example : git pull origin master

git stash: Sometimes when you go to pull you may have changes you don't want to commit just yet. One option you have, other than committing, is to stash the changes. Use the command 'git stash' to stash your changes, and 'git stash apply' to re-apply your changes after your pull.

git diff HEAD :  If pull shows that there have been changes, then we can see what’s different from our last commit by using the git diff command.

We want the diff of our most recent commit, which we can refer to using the HEAD pointer.
Example: git diff HEAD

git checkout <target> : to (re)set the state of repo to target which are shown next to commit when you do a git log.

Ex: git checkout 7499a39992a606fb86caa86f161ff7f33483648234287

You can view the previous state of your files here. To return to the master branch to see the most current state of your files, do:
git checkout master

git branch <branch name> : creates a copy (or branch) of the main code.

git branch : list all branches

git checkout <branch name> : switch to branch name

git rm <filenames> or git rm ‘*.txt’ : to remove or delete files and stage for commit, all in one step. 

Make changes to code and commit on the branch and then to merge the changes from branch to master  and then delete the branch, do following:

git checkout master

git merge <branch name to which changes (features or big fixes for ex. Have been applied)>

git branch -d <branch name> to delete a branch. (For branches that have already been merged with master) 

git branch -d -f <branch name>  : for branches that haven’t been merged to master (like abandoned features)

Now that all changes are made to local repo, don’t forget to update the remote repo as below:

git push (since we previously ran git push -u origin master, it remembers the setting thanks to the -u option and so we didn’t have to type git push origin master )



Some Important Definitions:

Staging Area: A place where we can group files together before we "commit" them to Git.

Commit : A "commit" is a snapshot of our repository. This way if we ever need to look back at the changes we've made (or if someone else does), we will see a nice timeline of all changes.

staged : files that are ready to be committed (say after git add)

unstaged : Files with changes that have not been prepared to be committed (that are currently being tracked by git).

untracked : Files aren't tracked by Git yet. This usually indicates a newly created file.

deleted : File has been deleted and is waiting to be removed from Git.

HEAD : The HEAD is a pointer that holds your position within all your different commits. By default HEAD points to your most recent commit, so it can be used as a quick way to reference that commit.

Branching : When developers are working on a feature or bug they'll often create a copy (aka. branch) of their code they can make separate commits to. Then when they're done they can merge this branch back into their main master branch. Branches are what naturally happens when you want to work on multiple features at the same time. You wouldn't want to end up with a master branch which has Feature A half done and Feature B half done. Rather you'd separate the code base into two "snapshots" (branches) and work on and commit to them separately. As soon as one was ready, you might merge this branch back into the master branch and push it to the remote server.

Pull Requests : If you're hosting your repo on GitHub, you can do something called a pull request.
A pull request allows the boss of the project to look through your changes and make comments before deciding to merge in the change. It's a really great feature that is used all the time for remote workers and open-source projects.

 


